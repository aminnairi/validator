"use strict";exports.Validator=class{constructor(t={},e={}){this.rules=t,this.translations=e}validate(t){const e=Object.entries(this.rules).reduce(((e,[r,i])=>{const s=i.split("|").map((t=>t.trim())),n=t[r],l=s.reduce(((i,s)=>{if("required"===s){if(null==n){let t=null;return t=void 0===this.translations[r]||void 0===this.translations[r][s]?r+" is required.":this.translations[r][s].replace("{}",r),{...i,[r]:[...i[r]||[],t]}}return i}if("integer"===s){if(null!=n&&!Number.isInteger(Number(n))){let t=null;return t=void 0===this.translations[r]||void 0===this.translations[r][s]?r+" should be an integer.":this.translations[r][s].replace("{}",r),{...i,[r]:[...i[r]||[],t]}}return i}if("email"===s){const t=/^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/u;if("string"==typeof n&&!t.test(n)){let t=null;return t=void 0===this.translations[r]||void 0===this.translations[r][s]?r+" should be a valid email.":this.translations[r][s].replace("{}",r),{...i,[r]:[...i[r]||[],t]}}return i}if("password"===s){const t=/(?=.*\d)(?=.*[a-z])(?=.*[A-Z])(?=.*\W).{8,}/u;if("string"==typeof n&&!t.test(n)){let t=null;return t=void 0===this.translations[r]||void 0===this.translations[r][s]?r+" should contain at least digits, lower & upper letters, symbols and at least 8 characters.":this.translations[r][s].replace("{}",r),{...i,[r]:[...i[r]||[],t]}}return i}if("date"===s){if(null!=n&&Number.isNaN(Date.parse(n))){let t=null;return t=void 0===this.translations[r]||void 0===this.translations[r][s]?r+" should be a valid date.":this.translations[r][s].replace("{}",r),{...i,[r]:[...i[r]||[],t]}}return i}if("string"===s){if("string"!=typeof n){let t=null;return t=void 0===this.translations[r]||void 0===this.translations[r][s]?r+" should be a string.":this.translations[r][s].replace("{}",r),{...i,[r]:[...i[r]||[],t]}}return e}if(s.startsWith("same")){const[e,l]=s.split(":");if(void 0===l)throw new Error('No value defined for the rule "same".');const a=l,o=t[a];if(null!=n&&o!==n){let t=null;return t=void 0===this.translations[r]||void 0===this.translations[r][e]?`${r} should be the same as ${a}.`:this.translations[r][e].replace("{}",r).replace("{}",a),{...i,[r]:[...i[r]||[],t]}}return i}if(s.startsWith("different")){const[e,l]=s.split(":");if(void 0===l)throw new Error('No value defined for the rule "different".');const a=l,o=t[a];if(null!=n&&o===n){let t=null;return t=void 0===this.translations[r]||void 0===this.translations[r][e]?`${r} should be different than ${a}.`:this.translations[r][e].replace("{}",r).replace("{}",a),{...i,[r]:[...i[r]||[],t]}}return i}if(s.startsWith("minimum")){const[t,e]=s.split(":");if(void 0===e)throw new Error('No value defined for the rule "minimum".');const l=Number(e);if(!Number.isFinite(l))throw new Error('No number defined for the rule "minimum".');const a=l,o=typeof n;if("undefined"!==o&&null!==n){if("number"==typeof n&&n<a){let e=null;return e=void 0===this.translations[r]||void 0===this.translations[r][t]?`${r} should be at least equals to ${a}.`:this.translations[r][t].replace("{}",r).replace("{}",a),{...i,[r]:[...i[r]||[],e]}}if("string"===o&&n.length<a){let e=null;return e=void 0===this.translations[r]||void 0===this.translations[r][t]?`${r} should have at least ${a} characters.`:this.translations[r][t].replace("{}",r).replace("{}",a),{...i,[r]:[...i[r]||[],e]}}}return i}if(s.startsWith("maximum")){const[t,e]=s.split(":");if(void 0===e)throw new Error('No value defined for the rule "maximum".');const l=Number(e);if(!Number.isFinite(l))throw new Error('No number defined for the rule "maximum".');const a=l,o=typeof n;if("undefined"!==o&&null!==n){if("number"===o&&n>a){let e=null;return e=void 0===this.translations[r]||void 0===this.translations[r][t]?`${r} should be at most equals to ${a}.`:this.translations[r][t].replace("{}",r).replace("{}",a),{...i,[r]:[...i[r]||[],e]}}if("string"===o&&n.length>a)return{...i,[r]:[...i[r]||[],`${r} should have at most ${a} characters.`]}}return i}if(s.startsWith("in")){const[t,e]=s.split(":");if(void 0===e)throw new Error('No value defined for the rule "in".');const l=e.split(",").map((t=>t.trim()));if(null!=n&&!l.includes(n)){const e=l.join(", ");let s=null;return s=void 0===this.translations[r]||void 0===this.translations[r][t]?`${r} should be one of the following: ${e}.`:this.translations[r][t].replace("{}",r).replace("{}",e),{...i,[r]:[...i[r]||[],s]}}return i}throw new Error(`Unrecognized rule: ${s}.`)}),{});return{...e,...l}}),{});return 0===Object.keys(e).length?null:e}};
