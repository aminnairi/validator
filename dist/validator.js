"use strict";exports.Validator=class{constructor(e){this.rules=e}validate(e){const r=Object.entries(this.rules).reduce(((r,[t,i])=>{const s=i.split("|").map((e=>e.trim())),o=e[t];return[...r,...s.reduce(((r,i)=>{if("required"===i)return void 0===o?[...r,t+" is required."]:r;if("email"===i){const e=/^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/;return"string"!=typeof o||e.test(o)?r:[...r,t+" should be a valid email."]}if("password"===i){const e=/(?=.*\d)(?=.*[a-z])(?=.*[A-Z])(?=.*\W).{8,}/;return"string"!=typeof o||e.test(o)?r:[...r,t+" should contain at least digits, lower & upper letters, symbols and at least 8 characters."]}if(i.startsWith("same")){const[,s]=i.split(":");if(void 0===s)throw new Error('No value defined for the rule "same".');const n=s,u=e[n];return null!=o&&u!==o?[...r,`${t} should be the same as ${n}.`]:r}if(i.startsWith("minimum")){const[,e]=i.split(":");if(void 0===e)throw new Error('No value defined for the rule "minimum".');const s=Number(e);if(!Number.isFinite(s))throw new Error('No number defined for the rule "minimum".');const n=s,u=Number(o)||0;return null!=o&&u<n?[...r,`${t} should be at least equals to ${n}.`]:r}if(i.startsWith("maximum")){const[,e]=i.split(":");if(void 0===e)throw new Error('No value defined for the rule "maximum".');const s=Number(e);if(!Number.isFinite(s))throw new Error('No number defined for the rule "maximum".');const n=s,u=Number(o)||0;return null!=o&&u>n?[...r,`${t} should be at most equals to ${n}.`]:r}if(i.startsWith("in")){const[,e]=i.split(":");if(void 0===e)throw new Error('No value defined for the rule "in".');const s=e.split(",").map((e=>e.trim()));return null==o||s.includes(o)?r:[...r,`${t} should be one of the following: ${s.join(", ")}.`]}throw new Error(`Unrecognized rule: ${i}.`)}),[])]}),[]);return 0===r.length?null:r}};
